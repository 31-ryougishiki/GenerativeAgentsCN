<script type="text/javascript">
	// Initialize variables from Flask context
	let step = {{ step|tojson }};
	let step_size = {{ sec_per_step|tojson }} * 1000; // Convert to milliseconds
	let zoom = {{ zoom|tojson }};
	if (zoom <= 0) zoom = document.documentElement.clientWidth / 4400;

	// bug修复 按钮显示不灵敏
	let buttonPlay, buttonPause, buttonShowConversation, buttonHideConversation, buttonToggleBuildingNames;
	let currentTime, textConversation; // 时间和对话文本也全局声明（原有可能已声明，确保一致）


	// 新增：建筑名称显示控制相关变量
	let buildingTexts = []; // 存储所有建筑名称文本对象的数组
	let showBuildingNames = true; // 初始状态：显示建筑名称

	// ================================= 豆包新增：对话筛选相关变量 =================================
	let selectedPersona = "所有人"; // 选中的人物，默认显示所有人
	let allPersonaNames = []; // 存储所有人物名称的数组
	let dropdownButton, dropdownOptions; // 下拉框触发按钮和选项容器
	let dropdownVisible = false; // 下拉框是否显示的状态
	// ================================= 新增结束 =================================

	// ================================= 豆包新增：对话历史存储变量 =================================
	let conversationHistory = []; // 存储所有历史对话，格式：[{key: 时间密钥, text: 对话文本}]
	// ================================= 新增结束 =================================

	// ================================= 豆包新增：滑动条相关变量 =================================
	let conversationContainer; // 对话文本的裁剪容器
	let scrollbarBg, scrollbarThumb; // 滑动条背景和滑块
	let isDragging = false; // 是否正在拖动滑块
	const containerHeight = 600; // 对话框固定高度（可调整，比如600px）
	const scrollbarWidth = 12; // 滑动条宽度
	const scrollbarMargin = 8; // 滑动条与对话框的间距
	// ================================= 新增结束 =================================

	let tile_width = 32;
	let movement_speed = {{ play_speed|tojson }};
	let execute_count_max = tile_width / movement_speed;
	let execute_count = execute_count_max;
	let all_movement = {{ all_movement|tojson }};

	let datetime_options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
	let start_datetime = new Date(Date.parse({{ start_datetime|tojson }}));

	// Persona related variables
	let persona_names = {{ persona_init_pos|tojson }};
	var spawn_tile_loc = {};
	for (var key in persona_names) {
		spawn_tile_loc[key] = persona_names[key];
		// ================================= 豆包新增：收集所有人物名称 =================================
		allPersonaNames.push(key);
		// ================================= 新增结束 =================================
	}

	var personas = {};
	var pronunciatios = {};
	let anims_direction;
	let pre_anims_direction;
	let pre_anims_direction_dict = {};

	let movement_target = {};

	let finished = false;
	let paused = false;

	// Phaser configuration
	const config = {
		type: Phaser.AUTO,
		// width: 4480,
		// height: 3200,
        width: document.documentElement.clientWidth / zoom,
        height: document.documentElement.clientHeight / zoom,
		parent: "game-container",
        mode: Phaser.Scale.FIT,
		pixelArt: true,
		physics: {
			default: "arcade",
			arcade: {
				gravity: { y: 0 }
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		},
		scale: {
			zoom: zoom
		}
	};

	// Create Phaser game instance
	const game = new Phaser.Game(config);
	let cursors;
	let player;

	// Preload function
	function preload() {
		this.load.crossOrigin = "";

		// Load building data
		this.load.json("buildingData", "static/assets/village/tilemap/大建筑.json");
		
		// Load images
		this.load.image("blocks_1", "static/assets/village/tilemap/blocks_1.png");
		this.load.image("walls", "static/assets/village/tilemap/Room_Builder_32x32.png");
		this.load.image("interiors_pt1", "static/assets/village/tilemap/interiors_pt1.png");
		this.load.image("interiors_pt2", "static/assets/village/tilemap/interiors_pt2.png");
		this.load.image("interiors_pt3", "static/assets/village/tilemap/interiors_pt3.png");
		this.load.image("interiors_pt4", "static/assets/village/tilemap/interiors_pt4.png");
		this.load.image("interiors_pt5", "static/assets/village/tilemap/interiors_pt5.png");
		this.load.image("CuteRPG_Field_B", "static/assets/village/tilemap/CuteRPG_Field_B.png");
		this.load.image("CuteRPG_Field_C", "static/assets/village/tilemap/CuteRPG_Field_C.png");
		this.load.image("CuteRPG_Harbor_C", "static/assets/village/tilemap/CuteRPG_Harbor_C.png");
		this.load.image("CuteRPG_Village_B", "static/assets/village/tilemap/CuteRPG_Village_B.png");
		this.load.image("CuteRPG_Forest_B", "static/assets/village/tilemap/CuteRPG_Forest_B.png");
		this.load.image("CuteRPG_Desert_C", "static/assets/village/tilemap/CuteRPG_Desert_C.png");
		this.load.image("CuteRPG_Mountains_B", "static/assets/village/tilemap/CuteRPG_Mountains_B.png");
		this.load.image("CuteRPG_Desert_B", "static/assets/village/tilemap/CuteRPG_Desert_B.png");
		this.load.image("CuteRPG_Forest_C", "static/assets/village/tilemap/CuteRPG_Forest_C.png");

		// Load tilemap JSON
		this.load.tilemapTiledJSON("map", "static/assets/village/tilemap/tilemap.json");

		this.load.atlas("atlas", "static/assets/village/agents/伊莎贝拉/texture.png", filename="static/assets/village/agents/sprite.json");

		// Load persona atlases
		for (var p in persona_names) {
			image_static = "static/assets/village/agents/" + p + "/texture.png";
			this.load.atlas(p, image_static, filename="static/assets/village/agents/sprite.json");
		}
	}

	// ================================= 豆包新增：创建下拉框选项的工具函数 =================================
	function createDropdownOption(scene, x, y, text, onClick) {
		const option = scene.add.text(x, y, text, {
			font: "40px 黑体",
			fill: "#000000",
			backgroundColor: "#ffffcc",
			padding: { x: 20, y: 8 },
			align: "center"
		});
		option.setInteractive();
		option.on("pointerdown", onClick);
		option.setDepth(11); // 层级高于聊天框（10），确保可见
		return option;
	}
	// ================================= 新增结束 =================================

	// Create function
	function create() {
		const map = this.make.tilemap({ key: "map" });

		// Add tilesets and layers
		const collisions = map.addTilesetImage("blocks", "blocks_1");
		const walls = map.addTilesetImage("Room_Builder_32x32", "walls");
		const interiors_pt1 = map.addTilesetImage("interiors_pt1", "interiors_pt1");
		const interiors_pt2 = map.addTilesetImage("interiors_pt2", "interiors_pt2");
		const interiors_pt3 = map.addTilesetImage("interiors_pt3", "interiors_pt3");
		const interiors_pt4 = map.addTilesetImage("interiors_pt4", "interiors_pt4");
		const interiors_pt5 = map.addTilesetImage("interiors_pt5", "interiors_pt5");
		const CuteRPG_Field_B = map.addTilesetImage("CuteRPG_Field_B", "CuteRPG_Field_B");
		const CuteRPG_Field_C = map.addTilesetImage("CuteRPG_Field_C", "CuteRPG_Field_C");
		const CuteRPG_Harbor_C = map.addTilesetImage("CuteRPG_Harbor_C", "CuteRPG_Harbor_C");
		const CuteRPG_Village_B = map.addTilesetImage("CuteRPG_Village_B", "CuteRPG_Village_B");
		const CuteRPG_Forest_B = map.addTilesetImage("CuteRPG_Forest_B", "CuteRPG_Forest_B");
		const CuteRPG_Desert_C = map.addTilesetImage("CuteRPG_Desert_C", "CuteRPG_Desert_C");
		const CuteRPG_Mountains_B = map.addTilesetImage("CuteRPG_Mountains_B", "CuteRPG_Mountains_B");
		const CuteRPG_Desert_B = map.addTilesetImage("CuteRPG_Desert_B", "CuteRPG_Desert_B");
		const CuteRPG_Forest_C = map.addTilesetImage("CuteRPG_Forest_C", "CuteRPG_Forest_C");

		let tileset_group_1 = [CuteRPG_Field_B, CuteRPG_Field_C, CuteRPG_Harbor_C, CuteRPG_Village_B,
			CuteRPG_Forest_B, CuteRPG_Desert_C, CuteRPG_Mountains_B, CuteRPG_Desert_B, CuteRPG_Forest_C,
			interiors_pt1, interiors_pt2, interiors_pt3, interiors_pt4, interiors_pt5, walls];
		const bottomGroundLayer = map.createLayer("Bottom Ground", tileset_group_1, 0, 0);
		const exteriorGroundLayer = map.createLayer("Exterior Ground", tileset_group_1, 0, 0);
		const exteriorDecorationL1Layer = map.createLayer("Exterior Decoration L1", tileset_group_1, 0, 0);
		const exteriorDecorationL2Layer = map.createLayer("Exterior Decoration L2", tileset_group_1, 0, 0);
		const interiorGroundLayer = map.createLayer("Interior Ground", tileset_group_1, 0, 0);
		const wallLayer = map.createLayer("Wall", [CuteRPG_Field_C, walls], 0, 0);
		const interiorFurnitureL1Layer = map.createLayer("Interior Furniture L1", tileset_group_1, 0, 0);
		const interiorFurnitureL2Layer = map.createLayer("Interior Furniture L2 ", tileset_group_1, 0, 0);
		const foregroundL1Layer = map.createLayer("Foreground L1", tileset_group_1, 0, 0);
		const foregroundL2Layer = map.createLayer("Foreground L2", tileset_group_1, 0, 0);

		const collisionsLayer = map.createLayer("Collisions", collisions, 0, 0);

		collisionsLayer.setCollisionByProperty({ collide: true });

		collisionsLayer.setDepth(-1);
		foregroundL1Layer.setDepth(2);
		foregroundL2Layer.setDepth(2);
		
		// ================================= 新增代码开始 =================================
		// 1. 获取加载的建筑数据
		const buildingData = this.cache.json.get("buildingData"); // 对应preload中的key
		const tileWidth = 32; // 与原代码tile_width一致

		// 2. 遍历所有建筑，筛选「占点数>10」的建筑
		Object.entries(buildingData).forEach(([buildingName, coords]) => {
			// coords是建筑的瓦片坐标数组，length即占点数
			if (coords.length > 30) {
				// 3. 计算建筑的中心点（瓦片坐标平均值）
				let totalX = 0;
				let totalY = 0;
				coords.forEach(([x, y]) => {
					totalX += x;
					totalY += y;
				});
				// 瓦片中心点坐标（平均值）
				const centerTileX = totalX / coords.length;
				const centerTileY = totalY / coords.length;
				// 转换为像素坐标（适配32x32瓦片，调整偏移量让文字居中）
				const pixelX = centerTileX * tileWidth + tileWidth / 2;
				const pixelY = centerTileY * tileWidth + tileWidth / 2;

				// 4. 创建建筑名称文本标签
				const buildingText = this.add.text(
					pixelX,
					pixelY,
					buildingName,
					{
					font: "50px 黑体",
					fill: "#ffffff", // 白色文字
					backgroundColor: "#333333", // 半透明黑色背景（80是透明度）
					padding: { x: 10, y: 4 }, // 内边距
					borderRadius: 4, // 圆角
					align: "center"
					}
				);

				// 5. 文本样式优化（关键）
				buildingText.setOrigin(0.5, 0.5); // 锚点居中（对应中心点坐标）
				buildingText.setDepth(1.5); // 深度介于墙壁（1）和前景（2）之间，确保可见
				buildingText.setScrollFactor(1); // 跟随地图滚动（建筑是地图一部分）
				buildingText.alpha = 0.9; // 透明度，避免遮挡建筑细节

				// ================================= 新增：存入数组 =================================
				buildingTexts.push(buildingText); // 将文本对象加入数组，便于后续控制
			}

		});
		// ================================= 新增代码结束 =================================


		const canvas = game.canvas;
		canvas.addEventListener("wheel", (event) => {
			event.stopPropagation();
		}, { passive: false, capture: true });

		// 原函数：function add_text(game, x, y, text, background) {
		// 修改后：增加 textColor 参数，默认值 #000000（保持其他UI黑色）
		function add_text(game, x, y, text, background, textColor = "#000000") {
			res = game.add.text(
				x,
				y,
				text,
				{
					font: "40px 黑体",
					fontWeight: "normal",
					fill: textColor, // 用传入的颜色，默认黑色
					backgroundColor: background,
					padding: { x: 20, y: 8},
					align: "left",
					wordWrap: { width: document.documentElement.clientWidth * 0.8 / zoom, useAdvancedWrap: true },
				}
			);

			res.setDepth(10);
			res.alpha = 0.8;
			res.setScrollFactor(0);

			return res;
		}

		posX = 20;
		posY = 20;

		// Add button: play, pause ...
		buttonPlay = add_text(this, posX, posY, "[运行]", "#ffffcc");
		buttonPlay.setInteractive();
		posX += buttonPlay.width + 10;

		buttonPause = add_text(this, posX, posY, " 暂停 ", "#ffffcc");
		buttonPause.setInteractive();
		posX += buttonPause.width + 10;

		buttonShowConversation = add_text(this, posX, posY, "[显示对话]", "#ffffcc");
		buttonShowConversation.setInteractive();
		posX += buttonShowConversation.width + 10;

		buttonHideConversation = add_text(this, posX, posY, " 隐藏对话 ", "#ffffcc");
		buttonHideConversation.setInteractive();
		posX += buttonHideConversation.width + 10;
		
		// ================================= 新增按钮开始 =================================
		// 新增：建筑名称切换按钮（初始文本为「隐藏建筑名称」）
		buttonToggleBuildingNames = add_text(this, posX, posY, "[隐藏建筑名称]", "#ffffcc");
		buttonToggleBuildingNames.setInteractive();
		posX += buttonToggleBuildingNames.width + 10; // 按钮位置右移，与其他按钮并排
		// ================================= 新增按钮结束 =================================

		// ================================= 新增：创建对话筛选下拉框 =================================
		// 1. 创建下拉框触发按钮（放在建筑名称按钮右侧）
		dropdownButton = add_text(this, posX, posY, "[筛选对话：所有人]", "#ffffcc");
		dropdownButton.setInteractive();
		posX += dropdownButton.width + 10; // 按钮位置右移，与其他按钮并排

		// 2. 创建下拉选项容器（初始隐藏）
		dropdownOptions = this.add.container(dropdownButton.x, dropdownButton.y + dropdownButton.height + 5);
		dropdownOptions.setVisible(false);
		dropdownOptions.setDepth(11); // 确保在最上层

		// 3. 添加“所有人”选项（修正：加入容器，与其他选项位置一致）
		let optionY = 0;
		const allOption = createDropdownOption(this, 0, optionY, "所有人", () => {
			selectedPersona = "所有人";
			dropdownButton.text = "[筛选对话：所有人]";
			dropdownVisible = false;
			dropdownOptions.setVisible(false);
		});
		dropdownOptions.add(allOption); // 关键修复：将“所有人”选项加入容器

		// 4. 添加所有人物选项（动态生成）
		allPersonaNames.forEach((persona, index) => {
			optionY = (index + 1) * (allOption.height + 5); // 每个选项向下偏移
			const personaOption = createDropdownOption(this, 0, optionY, persona, () => {
				selectedPersona = persona;
				dropdownButton.text = `[筛选对话：${persona}]`; // 更新按钮文本显示当前选中人物
				dropdownVisible = false;
				dropdownOptions.setVisible(false);
			});
			dropdownOptions.add(personaOption);
		});

		// 5. 下拉框触发按钮点击事件（显示/隐藏选项）
		dropdownButton.on("pointerdown", () => {
			dropdownVisible = !dropdownVisible;
			dropdownOptions.setVisible(dropdownVisible);
		});

		// 6. 点击空白区域关闭下拉框（优化体验）
		this.input.on("pointerdown", (pointer) => {
			if (!dropdownButton.getBounds().contains(pointer.x, pointer.y) &&
				!dropdownOptions.getBounds().contains(pointer.x, pointer.y)) {
				dropdownVisible = false;
				dropdownOptions.setVisible(false);
			}
		});
		// ================================= 新增结束 =================================

		// Setup play and pause button
		buttonPlay.on("pointerdown", function() {
			if (finished) return;
			buttonPlay.text = "[运行]";
			buttonPause.text = " 暂停 ";
			paused = false;
		});

		buttonPause.on("pointerdown", function() {
			if (finished) return;
			buttonPlay.text = " 运行 ";
			buttonPause.text = "[暂停]";
			paused = true;
		});

		buttonShowConversation.on("pointerdown", function() {
			buttonShowConversation.text = "[显示对话]";
			buttonHideConversation.text = " 隐藏对话 ";
			textConversation.setVisible(true);
		});

		buttonHideConversation.on("pointerdown", function() {
			buttonShowConversation.text = " 显示对话 ";
			buttonHideConversation.text = "[隐藏对话]";
			textConversation.setVisible(false);
		});

		// ================================= 新增按钮逻辑开始 =================================
		buttonToggleBuildingNames.on("pointerdown", function() {
			showBuildingNames = !showBuildingNames; // 切换状态（显示↔隐藏）
			// 更新按钮文本（同步状态）
			if (showBuildingNames) {
			buttonToggleBuildingNames.text = "[隐藏建筑名称]"; // 当前显示→按钮显示「隐藏」
			buildingTexts.forEach(text => text.setVisible(true)); // 显示所有建筑名称
			} else {
			buttonToggleBuildingNames.text = " 显示建筑名称 "; // 当前隐藏→按钮显示「显示」
			buildingTexts.forEach(text => text.setVisible(false)); // 隐藏所有建筑名称
			}
		});
		// ================================= 新增按钮逻辑结束 =================================

		// Show current time
		currentTime = add_text(this, posX, posY, "", "#ccffcc");

		// Show conversation content
		textConversation = add_text(this, 20, posY + currentTime.height + 10, " —— ", "#ffffff");
		textConversation.alpha = 1;
		// 3. 关键修改：缩小字体+减少内边距（实现"稍微小一点"）
		textConversation.setStyle({ font: "32px 黑体" }); // 字体从40px改成32px（核心缩小）
		textConversation.setPadding(15, 6); // 内边距：左右从20→15px，上下从8→6px（背景框更紧凑）

		// Setup camera
		player = this.physics.add.sprite(2440, 500, "atlas", "down").setSize(30, 40).setOffset(0, 0);
		player.setDepth(-1);
		const camera = this.cameras.main;
		camera.startFollow(player);
		camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
		cursors = this.input.keyboard.createCursorKeys();

		// Setup personas
		// We start by creating the game sprite objects.
		for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
			let persona_name = Object.keys(spawn_tile_loc)[i];
			let start_pos = [spawn_tile_loc[persona_name][0] * tile_width + tile_width / 2, spawn_tile_loc[persona_name][1] * tile_width + tile_width];
			let new_sprite = this.physics.add.sprite(start_pos[0], start_pos[1], persona_name, "down").setSize(30, 40).setOffset(0, 0);
			// Scale up the sprite
			new_sprite.displayWidth = 40;
			new_sprite.scaleY = new_sprite.scaleX;

			// Here, we are creating the persona and its pronunciatio sprites.
			personas[persona_name] = new_sprite;
			pronunciatios[persona_name] = this.add.text(
				new_sprite.body.x - 15,
				new_sprite.body.y - 15 - 25,
				"",
				{
					font: "18px monospace",
					fill: "#000000",
					backgroundColor: "#ffffcc",
					padding: { x: 4, y: 4},
					border:"solid",
					borderRadius:"10px"
				}
			).setDepth(3);
			pronunciatios[persona_name].alpha = 0.7;
		}

		// Create animations
		const anims = this.anims;
		for (let i = 0; i < Object.keys(persona_names).length; i++) {
			let persona_name = Object.keys(persona_names)[i];
			let left_walk_name = persona_name + "-left-walk";
			let right_walk_name = persona_name + "-right-walk";
			let down_walk_name = persona_name + "-down-walk";
			let up_walk_name = persona_name + "-up-walk";

			frameRate = 4;
			if (movement_speed > 1) frameRate = 8;

			anims.create({
				key: left_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "left-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: right_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "right-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: down_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "down-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: up_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "up-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});
		}
	}

	// Update function
	function update(time, delta) {

		// Move camera
		const camera_speed = 400;
		player.body.setVelocity(0);
		if (cursors.left.isDown) {
			player.body.setVelocityX(-camera_speed);
		}
		if (cursors.right.isDown) {
			player.body.setVelocityX(camera_speed);
		}
		if (cursors.up.isDown) {
			player.body.setVelocityY(-camera_speed);
		}
		if (cursors.down.isDown) {
			player.body.setVelocityY(camera_speed);
		}

		let curr_focused_persona = document.getElementById("temp_focus").textContent;
		if (curr_focused_persona != "") {
			player.body.x = personas[curr_focused_persona].body.x;
			player.body.y = personas[curr_focused_persona].body.y;
			document.getElementById("temp_focus").innerHTML = "";
		}

		if (finished || paused) {
			return;
		}

		// ================================= 实现：显示到此时间为止的对话历史 =================================
		curr_datetime = new Date(start_datetime.getTime());
		curr_year = curr_datetime.getFullYear().toString().padStart(4, "0");
		curr_month = (curr_datetime.getMonth() + 1).toString().padStart(2, "0");
		curr_day = curr_datetime.getDate().toString().padStart(2, "0");
		curr_hour = curr_datetime.getHours().toString().padStart(2, "0");
		curr_minute = curr_datetime.getMinutes().toString().padStart(2, "0");

		// 1. 构建当前时间密钥（与数据格式一致）
		const currentKey = `${curr_year}${curr_month}${curr_day}-${curr_hour}:${curr_minute}`;

		// 2. 安全获取当前对话数据，避免报错
		const conversationData = all_movement?.["conversation"] || {};
		const currentText = (conversationData[currentKey] || "").trim();

		// 3. 将当前对话添加到历史（去重，避免重复累积）
		const isAlreadyInHistory = conversationHistory.some(item => item.key === currentKey);
		if (currentText !== "" && !isAlreadyInHistory) {
			conversationHistory.push({ key: currentKey, text: currentText });
		}

		// 4. 筛选历史对话（按选中人物）- 优化：保留与目标人物相关的完整对话回合
		let filteredHistory = [];
		// 辅助函数：转义正则特殊字符（避免人物名称含*+等符号导致匹配出错）
		const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

		if (selectedPersona === "所有人") {
			// 显示所有人的完整历史（按时间顺序）
			filteredHistory = conversationHistory.map(item => 
				`\n【${item.key}】对话记录：\n${item.text}`
			);
		} else {
			// 筛选包含目标人物发言的完整对话回合（保留所有参与方的发言）
			const targetPersona = selectedPersona.replace("_", " "); // 统一处理下划线为空格
			const escapedPersona = escapeRegExp(targetPersona); // 转义正则特殊字符
			// 正则规则：行中包含目标人物名 + 中英文冒号（:或：） + 可选空格（冒号后有无空格都支持）
			const personaReg = new RegExp(`${escapedPersona}[：:]\\s*`, 'u'); // 'u'支持Unicode（中文）
			
			filteredHistory = conversationHistory.filter(item => {
				// 拆分单条对话为多行（每行一个发言）
				const lines = item.text.split("\n");
				// 判断：这条对话中是否存在目标人物的发言（只要有1行匹配即可）
				const hasPersonaSpeech = lines.some(line => 
					line.trim() !== "" && personaReg.test(line)
				);
				return hasPersonaSpeech; // 只有包含目标人物发言的对话才保留
			}).map(item => {
				// 格式化保留完整对话内容（包含所有参与方的发言）
				return `\n【${item.key}】与【${selectedPersona}】相关的完整对话：\n${item.text}`;
			});
		}

		// 5. 显示最终结果（历史对话或提示）
		if (filteredHistory.length > 0) {
			// 拼接所有历史对话，开头加标题
			const historyText = `=== 到此时间（${currentKey}）为止的对话历史 ===` + filteredHistory.join("\n");
			textConversation.setText(historyText);
		} else {
			// 无历史对话时显示提示
			textConversation.setText(`\n当前时间：${currentKey}\n暂无对话历史`);
		}
		// ================================= 实现结束 =================================

		// Moving personas
		for (let i = 0; i < Object.keys(personas).length; i++) {
			let curr_persona_name = Object.keys(personas)[i];
			let curr_persona = personas[curr_persona_name];
			let curr_pronunciatio = pronunciatios[Object.keys(personas)[i]];

			if (step in all_movement) {
				if (curr_persona_name.replace("_", " ") in all_movement[step]) {
					if (execute_count == execute_count_max) {
						let curr_x = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][0];
						let curr_y = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][1];
						movement_target[curr_persona_name] = [curr_x * tile_width, curr_y * tile_width];

						let action = all_movement[step][curr_persona_name.replace("_", " ")]["action"];

						let act = action;
						act = act.length > 25 ? act.substring(0, 20)+"..." : act;
						pronunciatios[curr_persona_name].setText(curr_persona_name + ": " + act);

						// Updating the status of each personas
						document.getElementById("agent_desc__"+curr_persona_name).innerHTML = all_movement["description"][curr_persona_name]["currently"];
						document.getElementById("current_action__"+curr_persona_name).innerHTML = action;
						document.getElementById("target_address__"+curr_persona_name).innerHTML = all_movement[step][curr_persona_name.replace("_", " ")]["location"];
					}

					if (execute_count > 0) {
						if (curr_persona.body.x < movement_target[curr_persona_name][0]) {
							curr_persona.body.x += movement_speed;
							anims_direction = "r";
							pre_anims_direction = "r";
							pre_anims_direction_dict[curr_persona_name] = "r";
						} else if (curr_persona.body.x > movement_target[curr_persona_name][0]) {
							curr_persona.body.x -= movement_speed;
							anims_direction = "l";
							pre_anims_direction = "l";
							pre_anims_direction_dict[curr_persona_name] = "l";
						} else if (curr_persona.body.y < movement_target[curr_persona_name][1]) {
							curr_persona.body.y += movement_speed;
							anims_direction = "d";
							pre_anims_direction = "d";
							pre_anims_direction_dict[curr_persona_name] = "d";
						} else if (curr_persona.body.y > movement_target[curr_persona_name][1]) {
							curr_persona.body.y -= movement_speed;
							anims_direction = "u";
							pre_anims_direction = "u";
							pre_anims_direction_dict[curr_persona_name] = "u";
						} else {
							anims_direction = "";
						}

						curr_pronunciatio.x = curr_persona.body.x - 15;
						curr_pronunciatio.y = curr_persona.body.y - 15 - 25;

						let left_walk_name = curr_persona_name + "-left-walk";
						let right_walk_name = curr_persona_name + "-right-walk";
						let down_walk_name = curr_persona_name + "-down-walk";
						let up_walk_name = curr_persona_name + "-up-walk";

						if (anims_direction == "l") {
							curr_persona.anims.play(left_walk_name, true);
						} else if (anims_direction == "r") {
							curr_persona.anims.play(right_walk_name, true);
						} else if (anims_direction == "u") {
							curr_persona.anims.play(up_walk_name, true);
						} else if (anims_direction == "d") {
							curr_persona.anims.play(down_walk_name, true);
						}
					}
				}
			} else {
				if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setTexture(curr_persona_name, "left");
				else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setTexture(curr_persona_name, "right");
				else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setTexture(curr_persona_name, "up");
				else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setTexture(curr_persona_name, "down");
				curr_persona.anims.stop();

				finished = true;
				buttonPlay.text = "[回放结束]";
				buttonPause.setVisible(false);
			}
		}

		if (execute_count == 0) {
			for (let i = 0; i < Object.keys(personas).length; i++) {
				let curr_persona_name = Object.keys(personas)[i];
				let curr_persona = personas[curr_persona_name];
				curr_persona.body.x = movement_target[curr_persona_name][0];
				curr_persona.body.y = movement_target[curr_persona_name][1];
			}
			execute_count = execute_count_max + 1;
			step = step + 1;

			start_datetime = new Date(start_datetime.getTime() + step_size);
			currentTime.setText(start_datetime.toLocaleTimeString("zh-CN", datetime_options));
		}

		execute_count -= 1;
	}
</script>